LIB "linalg.lib";
LIB "dmodapp.lib";
LIB "my_proc.lib";
ring R = (2,X),(Y, A, B, y_7_, y_6_, y_5_, y_4_, y_3_, y_2_, y_1_, y_0_, s2_4_, s2_5_, s2_6_, s2_7_, t1_4_, t1_5_, t1_6_, t1_7_, t1_8_, t1_9_, t1_10_, s2_0_, s2_1_, s2_2_, s2_3_, t1_0_, t1_1_, t1_2_, t1_3_, T2_0_, T2_1_, T2_3_, T2_5_, T2_6_, T2_8_, T2_9_, T2_11_, T2_12_, T2_14_, T2_16_, q3_0_, q3_1_, q3_2_, t1_11_, t1_12_, t1_13_, t1_14_, q2_4_, q2_5_, q2_6_, q2_7_, q2_8_, q2_9_, q2_10_, T2_2_, T2_4_, T2_7_, T2_10_, T2_13_, T2_15_, q3_3_, q3_4_, q3_5_, q3_6_, q2_0_, q2_1_, q2_2_, q2_3_, T1_0_, T1_1_, T1_3_, T1_5_, T1_6_, T1_8_, T1_9_, T1_11_, T1_12_, T1_14_, T1_16_, s1_4_, s1_5_, s1_6_, s1_7_, q2_11_, q2_12_, q2_13_, q2_14_, q1_0_, q1_1_, q1_2_, T1_2_, T1_4_, T1_7_, T1_10_, T1_13_, T1_15_, r_10_, r_9_, r_8_, r_7_, r_6_, r_5_, r_4_, s1_0_, s1_1_, s1_2_, s1_3_, q1_3_, q1_4_, q1_5_, q1_6_, r_14_, r_13_, r_12_, r_11_, r_3_, r_2_, r_1_, r_0_, T_16_, T_15_, T_14_, T_13_, T_12_, T_11_, T_10_, T_9_, T_8_, T_7_, T_6_, T_5_, T_4_, T_3_, T_2_, T_1_, T_0_, b_7_, b_6_, b_5_, b_4_, b_3_, b_2_, b_1_, b_0_, a_7_, a_6_, a_5_, a_4_, a_3_, a_2_, a_1_, a_0_),lp;

minpoly = X^8+X^4+X^3+X^2+1;

rtimer=0;
system("--ticks-per-sec",1000);
int t0 = rtimer;

ideal J1 = 
Y + y_0_*X^0 + y_1_*X^1 + y_2_*X^2 + y_3_*X^3 + y_4_*X^4 + y_5_*X^5 + y_6_*X^6 + y_7_*X^7,
T_0_ + a_0_*b_4_+a_1_*b_3_+a_2_*b_2_,
T_1_ + a_3_*b_1_+a_4_*b_0_,
T_2_ + a_0_*b_5_+a_1_*b_4_+a_2_*b_3_,
T_3_ + a_3_*b_2_+a_4_*b_1_+a_5_*b_0_,
T_4_ + a_0_*b_6_+a_1_*b_5_+a_2_*b_4_,
T_5_ + a_3_*b_3_+a_4_*b_2_+a_5_*b_1_,
T_6_ + a_6_+b_0_, //bug
T_7_ + a_0_*b_7_+a_1_*b_6_+a_2_*b_5_,
T_8_ + a_3_*b_4_+a_4_*b_3_+a_5_*b_2_,
T_9_ + a_6_*b_1_+a_7_*b_0_,
T_10_ + a_1_*b_7_+a_2_*b_6_+a_3_*b_5_,
T_11_ + a_4_*b_4_+a_5_*b_3_+a_6_*b_2_,
T_12_ + a_7_*b_1_,
T_13_ + a_2_*b_7_+a_3_*b_6_+a_4_*b_5_,
T_14_ + a_5_*b_4_+a_6_*b_3_+a_7_*b_2_,
T_15_ + a_3_*b_7_+a_4_*b_6_+a_5_*b_5_,
T_16_ + a_6_*b_4_+a_7_*b_3_,
r_0_ + a_0_*b_0_,
r_1_ + a_0_*b_1_+a_1_*b_0_,
r_2_ + a_0_*b_2_+a_1_*b_1_+a_2_*b_0_,
r_3_ + a_0_*b_3_+a_1_*b_2_+a_2_*b_1_+a_3_*b_0_,
r_11_ + a_4_*b_7_+a_5_*b_6_+a_6_*b_5_+a_7_*b_4_,
r_12_ + a_5_*b_7_+a_6_*b_6_+a_7_*b_5_,
r_13_ + a_6_*b_7_+a_7_*b_6_,
r_14_ + a_7_*b_7_,
q1_6_ + r_14_,
q1_5_ + r_13_,
q1_4_ + r_12_,
q1_3_ + r_11_,
s1_3_ + r_3_,
s1_2_ + r_2_,
s1_1_ + r_1_,
s1_0_ + r_0_,
r_4_ + T_0_+T_1_,
r_5_ + T_2_+T_3_,
r_6_ + T_4_+T_5_+T_6_,
r_7_ + T_7_+T_8_+T_9_,
r_8_ + T_10_+T_11_+T_12_,
r_9_ + T_13_+T_14_,
r_10_ + T_15_+T_16_,
T1_15_ + 1*q1_6_+0*q1_5_+0*q1_4_,
T1_13_ + 1*q1_6_+1*q1_5_+0*q1_4_,
T1_10_ + 1*q1_6_+1*q1_5_+1*q1_4_,
T1_7_ + 0*q1_6_+1*q1_5_+1*q1_4_,
T1_4_ + 1*q1_6_+0*q1_5_+1*q1_4_,
T1_2_ + 1*q1_5_+0*q1_4_+1*q1_3_,
q1_2_ + r_10_,
q1_1_ + r_9_,
q1_0_ + r_8_,
q2_14_ + 1*q1_6_,
q2_13_ + 0*q1_6_+1*q1_5_,
q2_12_ + 0*q1_6_+0*q1_5_+1*q1_4_,
q2_11_ + 0*q1_6_+0*q1_5_+0*q1_4_+1*q1_3_,
s1_7_ + r_7_,
s1_6_ + r_6_,
s1_5_ + r_5_,
s1_4_ + r_4_,
T1_16_ + 0*q1_3_+1*q1_2_,
T1_14_ + 0*q1_3_+0*q1_2_+1*q1_1_,
T1_12_ + 1*q1_0_,
T1_11_ + 0*q1_3_+0*q1_2_+0*q1_1_,
T1_9_ + 0*q1_0_,
T1_8_ + 1*q1_3_+0*q1_2_+0*q1_1_,
T1_6_ + 0*q1_0_,
T1_5_ + 1*q1_3_+1*q1_2_+0*q1_1_,
T1_3_ + 1*q1_2_+1*q1_1_+0*q1_0_,
T1_1_ + 1*q1_1_+1*q1_0_,
T1_0_ + 1*q1_4_+0*q1_3_+1*q1_2_,
q2_3_ + 1*q1_3_+0*q1_2_+1*q1_1_+1*q1_0_,
q2_2_ + 1*q1_2_+0*q1_1_+1*q1_0_,
q2_1_ + 1*q1_1_+0*q1_0_,
q2_0_ + 1*q1_0_,
q3_6_ + q2_14_,
q3_5_ + q2_13_,
q3_4_ + q2_12_,
q3_3_ + q2_11_,
T2_15_ + 1*q3_6_+0*q3_5_+0*q3_4_,
T2_13_ + 1*q3_6_+1*q3_5_+0*q3_4_,
T2_10_ + 1*q3_6_+1*q3_5_+1*q3_4_,
T2_7_ + 0*q3_6_+1*q3_5_+1*q3_4_,
T2_4_ + 1*q3_6_+0*q3_5_+1*q3_4_,
T2_2_ + 1*q3_5_+0*q3_4_+1*q3_3_,
q2_10_ + T1_15_+T1_16_,
q2_9_ + T1_13_+T1_14_,
q2_8_ + T1_10_+T1_11_+T1_12_,
q2_7_ + T1_7_+T1_8_+T1_9_,
q2_6_ + T1_4_+T1_5_+T1_6_,
q2_5_ + T1_2_+T1_3_,
q2_4_ + T1_0_+T1_1_,
t1_14_ + 1*q3_6_,
t1_13_ + 0*q3_6_+1*q3_5_,
t1_12_ + 0*q3_6_+0*q3_5_+1*q3_4_,
t1_11_ + 0*q3_6_+0*q3_5_+0*q3_4_+1*q3_3_,
q3_2_ + q2_10_,
q3_1_ + q2_9_,
q3_0_ + q2_8_,
T2_16_ + 0*q3_3_+1*q3_2_,
T2_14_ + 0*q3_3_+0*q3_2_+1*q3_1_,
T2_12_ + 1*q3_0_,
T2_11_ + 0*q3_3_+0*q3_2_+0*q3_1_,
T2_9_ + 0*q3_0_,
T2_8_ + 1*q3_3_+0*q3_2_+0*q3_1_,
T2_6_ + 0*q3_0_,
T2_5_ + 1*q3_3_+1*q3_2_+0*q3_1_,
T2_3_ + 1*q3_2_+1*q3_1_+0*q3_0_,
T2_1_ + 1*q3_1_+1*q3_0_,
T2_0_ + 1*q3_4_+0*q3_3_+1*q3_2_,
t1_3_ + 1*q3_3_+0*q3_2_+1*q3_1_+1*q3_0_,
t1_2_ + 1*q3_2_+0*q3_1_+1*q3_0_,
t1_1_ + 1*q3_1_+0*q3_0_,
t1_0_ + 1*q3_0_,
s2_3_ + t1_3_,
s2_2_ + t1_2_,
s2_1_ + t1_1_,
s2_0_ + t1_0_,
t1_10_ + T2_15_+T2_16_,
t1_9_ + T2_13_+T2_14_,
t1_8_ + T2_10_+T2_11_+T2_12_,
t1_7_ + T2_7_+T2_8_+T2_9_,
t1_6_ + T2_4_+T2_5_+T2_6_,
t1_5_ + T2_2_+T2_3_,
t1_4_ + T2_0_+T2_1_,
s2_7_ + t1_7_,
s2_6_ + t1_6_,
s2_5_ + t1_5_,
s2_4_ + t1_4_,
y_0_ + s1_0_+s2_0_,
y_1_ + s1_1_+s2_1_,
y_2_ + s1_2_+s2_2_,
y_3_ + s1_3_+s2_3_,
y_4_ + s1_4_+s2_4_,
y_5_ + s1_5_+s2_5_,
y_6_ + s1_6_+s2_6_,
y_7_ + s1_7_+s2_7_,
A + a_0_*X^0 + a_1_*X^1 + a_2_*X^2 + a_3_*X^3 + a_4_*X^4 + a_5_*X^5 + a_6_*X^6 + a_7_*X^7,
B + b_0_*X^0 + b_1_*X^1 + b_2_*X^2 + b_3_*X^3 + b_4_*X^4 + b_5_*X^5 + b_6_*X^6 + b_7_*X^7;

ideal J0 =
a_7_^2 - a_7_,
a_6_^2 - a_6_,
a_5_^2 - a_5_,
a_4_^2 - a_4_,
a_3_^2 - a_3_, 
a_2_^2 - a_2_,
a_1_^2 - a_1_,
a_0_^2 - a_0_,
b_7_^2 - b_7_,
b_6_^2 - b_6_,
b_5_^2 - b_5_,
b_4_^2 - b_4_,
b_3_^2 - b_3_, 
b_2_^2 - b_2_,
b_1_^2 - b_1_,
b_0_^2 - b_0_;

poly spec = Y + A*B;

int dps = 8;

//check if the circuit indeed implements specification
poly rema = reduce(spec,J1+J0);
if (rema == 0)
{
	"circuit implements specification, exiting";
	quit;
}
else
{
	//"remainder",rema;
	"circuit doesn't implement specification, attempting rectification";
}
int t1 = rtimer-t0;
"time for verification",t1;

//list coneTips =  remainder_partition(rema,dps);

//list rectCheck = prune_logical_cone(coneTips,J1);
list rectCheck = T_6_;
int t2 = rtimer-t1;
"time for identifying rectifiable nets",t2;

int rectified = 0;
for(int rect=1; rect<=size(rectCheck);rect++)
{	
	if (rectified == 0)
	{
		//rectifying at location rf
		//poly rf = rectCheck[rect];
		poly rf = T_6_;
		"checking for rectification at", rf;
		ideal ckt_imp = J1;
		
		int ind_r = get_index(ckt_imp, rf);
		int ind_Z = get_index(ckt_imp, Y);
		
		ideal IL = ckt_imp;
		IL[ind_r] = rf+1;
		ideal IH = ckt_imp;
		IH[ind_r] = rf;
		
		poly rL = reduce(spec,IL+J0);
		poly rH = reduce(spec,IH+J0);
		
		//"rL",rL;
		//"rH",rH;

		ideal rlh = groebner((rL*rH)+J0);
		//"ideal rlh is",rlh;
		int t3 = rtimer-t2;
		"time for rectification check until the correction net",t3;

		if (size(rlh)==size(J0))
		{	
			"Circuit Rectifiable at location",rf;
			int lenI = size(ckt_imp);
			ideal Jf = ckt_imp[1..(ind_r-1)];
			ideal Js = ckt_imp[(ind_r+1)..lenI];
			poly quo;
			poly rem;
			poly prem;
		
			prem = reduce(spec,Jf);
		
			rem, quo = multivariate_burg(prem,lead(rf),J0); 
		
			//"remainder",rem;
			//"quotient",quo;
		
			ideal dec = variables(quo);
			ideal JCp = quo,Js;
			if (size(dec)>=1)
			{
				"quotient is not a constant";
				ideal JG = slimgb(JCp);
				matrix V = lift(JG,rem);
				matrix Vt = transpose(V);
				//Vt;
				matrix U = lift(JCp,JG);
				//U;
				poly sol;
				int i;
				for(i=1;i<=size(JG);i++)
				{
					sol = sol + (Vt[1,i]*U[1,i]);
				}
			}
			else
			{	
				"quotient is a constant";
				if (quo != 1)
				{
					matrix quoi = inverse(quo);
				}
				else
				{
					matrix quoi = 1;
				}
				poly irem   = quoi[1,1]*rem;
				poly sol    = reduce(irem,Js+J0);	
			}
			"solution for P is",sol;
			int t4 = rtimer-t3;
			"time for identifying solution using UC",t4;
			poly correc = rf+sol;
			poly corem = reduce(spec, Jf+Js+correc+J0);
		
			"applying correction to circuit at",rf,"with solution",sol,":remainder after reduction is", corem;
			rectified = 1;
		}
		else
		{
			"Circuit not rectifiable at location",rf;
		}
	}
}
"end of computations",rtimer-t0;quit;