LIB "linalg.lib";
LIB "dmodapp.lib";
LIB "my_proc.lib";
ring R = (2,X),(Y, A, B, y_1_, y_0_, s2_0_, s2_1_, t1_0_, t1_1_, t1_2_, q3_0_, q2_0_, q2_1_, q2_2_, s1_0_, s1_1_, q1_0_, r_2_, r_1_, r_0_, b_1_, b_0_, a_1_, a_0_),lp;

minpoly = X^2+X^1+1;

rtimer=0;
system("--ticks-per-sec",1000);
int t0 = rtimer;

ideal J1 = 
Y + y_0_*X^0 + y_1_*X^1,
r_0_ + a_0_*b_0_,
r_1_ + a_0_*b_1_+a_1_*b_0_,
r_2_ + a_1_*b_1_,
q1_0_ + r_2_,
s1_1_ + r_1_,
s1_0_ + r_0_,
q2_2_ + 1*q1_0_,
q2_1_ + 1*q1_0_,
q2_0_ + 1*q1_0_,
q3_0_ + q2_2_,
t1_2_ + 1*q3_0_,
t1_1_ + 1*q3_0_,
t1_0_ + 1*q3_0_,
s2_1_ + t1_1_,
s2_0_ + t1_0_,
y_0_ + s1_0_+s2_0_,
y_1_ + s1_1_+s2_1_,
A + a_0_*X^0 + a_1_*X^1,
B + b_0_*X^0 + b_1_*X^1;

ideal J0 =
a_1_^2 - a_1_,
a_0_^2 - a_0_,
b_1_^2 - b_1_,
b_0_^2 - b_0_;

//word level spec
poly spec = Y + A*B;

int dps = 2;

//check if the circuit indeed implements specification
poly rema = reduce(spec,J1+J0);
if (rema == 0)
{
	"circuit implements specification, exiting";
	quit;
}
else
{
	"remainder",rema;
	"circuit doesn't implement specification, attempting rectification";
}

list coneTips,exps;
coneTips,exps =  remainder_partition(rema,dps);

/*int i;
string s = exps[1];
for(i=2;i<=size(exps);i++)
{
	s = s + "+" + exps[i];
}
s;*/
int i;
poly s;
for (i=1;i<=size(exps);i++)
{
	s = s + X^exps[i];
}
s;
list rectCheck = prune_logical_cone(coneTips,J1);

int rectified = 0;
for(int rect=1; rect<=size(rectCheck);rect++)
{	
	if (rectified == 0)
	{
		//rectifying at location rf
		poly rf = rectCheck[rect];
		"checking for rectification at", rf;
		ideal ckt_imp = J1;
		
		int t1;
		int ind_r = get_index(ckt_imp, rf);
		int ind_Z = get_index(ckt_imp, Z);
		
		ideal IL = ckt_imp;
		IL[ind_r] = rf+1;
		ideal IH = ckt_imp;
		IH[ind_r] = rf;
		
		int t1;
		
		poly rL = reduce(spec,IL+J0);
		poly rH = reduce(spec,IH+J0);
		
		//"rL",rL;
		//"rH",rH;

		poly rr = rL + rH;"rr-",rr;
		coneTips;

		//ideal Ql = quotient(J0,rL);
		//ideal Qh = quotient(J0,rH);		

		//"Quotient(rL)=",Ql;
		//"Quotient(rH)=",Qh;
		//rtimer-t0;

		/*ideal Qln = intersect((rL + J0),(rH + J0));
		ideal Qhn = groebner(Qln);
		rtimer-t0;
		"ideal Qhn is", Qhn;*/

		ideal Qlnn = groebner((rL*rH) + J0);
		"time here",rtimer-t0;
		"ideal Qlnn is", Qlnn;


		// ideal Gr = groebner(Ql+Qh+J0);
		// "groebner(Ql+Qh+J0)=",Gr;
		
		if (((reduce(Qlnn,J0)+0) == 0) and ((reduce(J0,Qlnn)+0) == 0))
		//if(s == rr)
		{
			"Circuit Rectifiable at location",rf;
			int lenI = size(ckt_imp);
			ideal Jf = ckt_imp[1..(ind_r-1)];
			ideal Js = ckt_imp[(ind_r+1)..lenI];
			poly quo;
			poly rem;
			poly prem;
		
			prem = reduce(spec,Jf);
		
			rem, quo = multivariate_burg(prem,lead(rf),J0); 
		
			//"remainder",rem;
			//"quotient",quo;
		
			ideal dec = variables(quo);
			ideal JCp = quo,Js;
			if (size(dec)>=1)
			{
				"quotient is not a constant";
				ideal JG = slimgb(JCp);
				matrix V = lift(JG,rem);
				matrix Vt = transpose(V);
				//Vt;
				matrix U = lift(JCp,JG);
				//U;
				poly sol;
				int i;
				for(i=1;i<=size(JG);i++)
				{
					sol = sol + (Vt[1,i]*U[1,i]);
				}
			}
			else
			{	
				"quotient is a constant";
				if (quo != 1)
				{
					matrix quoi = inverse(quo);
				}
				else
				{
					matrix quoi = 1;
				}
				poly irem   = quoi[1,1]*rem;
				poly sol    = reduce(irem,Js+J0);	
			}
			"solution for P is",sol; 
			poly correc = rf+sol;
			poly corem = reduce(spec, Jf+Js+correc+J0);
		
			"applying correction to circuit at",rf,"with solution",sol,":remainder after reduction is", corem;
			rectified = 1;
		}
		else
		{
			"Circuit not rectifiable at location",rf;
		}
	}
}
"time here",rtimer-t0;