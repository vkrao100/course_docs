LIB "multivariate_burg.lib";
LIB "primdec.lib";
LIB "control.lib";
LIB "linalg.lib";
LIB "my_proc.lib";

ring r = (2, x), (Z, A, B, z_0, z_1, r_0, e_0, e_1, e_2, e_3, s_5, s_4, s_3, s_2, s_1, s_0, a_0, a_1, b_1, b_0), lp; 

rtimer=0;
system("--ticks-per-sec",1000);
int t0 = rtimer;

minpoly = x^2 + x + 1;

proc xorgate(poly g, poly h)
{
	return(g+h);
}

proc andgate(poly g, poly h)
{
	return(g*h);
}

//bug at e_0, correction at e_0

//circuit -  2 bit mastrovito multiplier poly's
ideal J1 = 
Z + z_0 + z_1*x,
A + a_0 + a_1*x,
B + b_0 + b_1*x,
z_0 + xorgate(s_0,e_0),
z_1 + xorgate(e_0,r_0),
r_0 + xorgate(e_1,s_5),
//e_0 + xorgate(s_1,e_2),//correct - andgate
e_0 + xorgate(e_3,e_2),//correct - andgate
e_1 + s_2*e_2,
e_2 + xorgate(e_3,s_4),
//e_2 + xorgate(e_3,s_1),
e_3 + b_0*s_3,
s_0 + a_0*b_0,
s_1 + a_1*b_1,
s_2 + a_1*b_0,
s_3 + a_0 + b_0 + a_0*b_0,
s_4 + b_0 + 1,
s_5 + a_0*b_1;



//vanishing polynomials
ideal J0 = 
a_0^2 - a_0,
a_1^2 - a_1,
b_0^2 - b_0,
b_1^2 - b_1,
s_0^2 - s_0,
s_1^2 - s_1,
s_2^2 - s_2,
s_3^2 - s_3,
s_4^2 - s_4,
s_5^2 - s_5,
e_0^2 - e_0,
e_1^2 - e_1,
e_2^2 - e_2,
e_3^2 - e_3,
r_0^2 - r_0,
z_0^2 - z_0,
z_1^2 - z_1,
Z^4 - Z,
A^4 - A,
B^4 - B;

//word level spec
poly spec = Z + A*B;

//check if the circuit indeed implements specification
poly rema = reduce(spec,J1+J0);
if (rema == 0)
{
	"circuit implements specification, exiting";
	quit;
}
else
{
	"remainder",rema;
	"circuit doesn't implement specification, attempting rectification";
}

//rectifying at location rf
poly rf = e_0;
int mul_size = 2;
ideal ckt_imp = J1;

int t1;
int ind_r = get_index(ckt_imp, rf);
int ind_Z = get_index(ckt_imp, Z);

ideal IL = ckt_imp;
IL[ind_r] = rf+1;
ideal IH = ckt_imp;
IH[ind_r] = rf;

int t1;

poly rL = reduce(spec,IL+J0);
poly rH = reduce(spec,IH+J0);

"rL=",rL;"rH=",rH;
poly rr = rL + rH;
"rL+rH=",rr;

ideal Ql = quotient(J0,rL);
ideal Qh = quotient(J0,rH);

"Quotient(rL)=",Ql;
"Quotient(rH)=",Qh;

ideal Gr = groebner(Ql+Qh+J0);
"groebner(Ql+Qh+J0)=",Gr;
if(Gr == 1)
{
	"Circuit Rectifiable at location",rf;
	int lenI = size(ckt_imp);
	ideal Jf = ckt_imp[1..(ind_r-1)];
	ideal Js = ckt_imp[(ind_r+1)..lenI];
	poly quo;
	poly rem;
	poly prem;

	prem = reduce(spec,Jf);

	rem, quo = multivariate_burg(prem,lead(rf),J0); 

	"remainder",rem;
	"quotient",quo;

	ideal dec = variables(quo);
	ideal JCp = quo,Js;
	if (size(dec)>=1)
	{
		"quotient is not a constant";
		ideal JG = slimgb(JCp);
		matrix V = lift(JG,rem);
		matrix Vt = transpose(V);
		Vt;
		matrix U = lift(JCp,JG);
		U;
		poly sol;
		int i;
		for(i=1;i<=size(JG);i++)
		{
			sol = sol + (Vt[1,i]*U[1,i]);
		}
	}
	else
	{	
		"quotient is a constant";
		if (quo != 1)
		{
			matrix quoi = inverse(quo);
		}
		else
		{
			matrix quoi = 1;
		}
		poly irem   = quoi[1,1]*rem;
		poly sol    = reduce(irem,Js+J0);	
	}

	"solution for P is",sol; 
	poly correc = rf+sol;
	poly corem = reduce(spec, Jf+Js+correc+J0);

	"applying correction to circuit at",rf,"with solution",sol,":remainder after reduction is", corem;
}
else
{
	"Circuit not rectifiable at location",rf;
}

"time here",rtimer-t0;
//quit;