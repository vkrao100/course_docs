LIB "linalg.lib";
LIB "dmodapp.lib";
LIB "my_proc.lib";

ring R = (2, X), (w, Z, A, B, z_0_, z_1_, r_0, e_0, e_1, e_2, e_3, s_0, s_1, s_2, s_3, s_4, s_5, a_0, a_1, b_1, b_0), lp; 

rtimer=0;
system("--ticks-per-sec",1000);
int t0 = rtimer;

minpoly = X^2 + X + 1;

proc xorgate(poly g, poly h)
{
	return(g+h);
}

proc andgate(poly g, poly h)
{
	return(g*h);
}

//bug at e_0,

//circuit -  2 bit mastrovito multiplier poly's
ideal J1 = 
Z + z_0_ + z_1_*X,
A + a_0 + a_1*X,
B + b_0 + b_1*X,
z_0_ + xorgate(s_0,e_0),
z_1_ + xorgate(e_0,r_0),
r_0 + xorgate(e_1,s_5), // correct
//r_0 + andgate(e_1,s_5),//bug
e_0 + s_1*e_2,//correct
//e_0 + s_1+e_2, // bug
e_1 + s_2*e_2,
e_2 + xorgate(e_3,s_4),
//e_3 + b_0*s_3,//correct
e_3 + b_0+s_3,//bug
s_0 + a_0*b_0,//correct
//s_0 + a_0+b_0,//bug
s_1 + a_1*b_1,
s_2 + a_1*b_0,
s_3 + a_0 + b_0 + a_0*b_0,
s_4 + b_0 + 1,
s_5 + a_0*b_1;



//vanishing polynomials
ideal J0 = 
a_0^2 - a_0,
a_1^2 - a_1,
b_0^2 - b_0,
b_1^2 - b_1;	
/*s_0^2 - s_0,
s_1^2 - s_1,
s_2^2 - s_2,
s_3^2 - s_3,
s_4^2 - s_4,
s_5^2 - s_5,
e_0^2 - e_0,
e_1^2 - e_1,
e_2^2 - e_2,
e_3^2 - e_3,
r_0^2 - r_0,
z_0_^2 - z_0_,
z_1_^2 - z_1_,
Z^4 - Z,
A^4 - A,
B^4 - B;*/

//word level spec
poly spec = Z + A*B;

int dps = 2;

//check if the circuit indeed implements specification
poly rema = reduce(spec,J1+J0);
if (rema == 0)
{
	"circuit implements specification, exiting";
	quit;
}
else
{
	//"remainder",rema;
	"circuit doesn't implement specification, attempting rectification";
}
int t1 = rtimer-t0;
"time for verification",t1;

list coneTips =  remainder_partition(rema,dps);

list rectCheck = prune_logical_cone(coneTips,J1);
int t2 = rtimer-t1;
"time for identifying rectifiable nets",t2;

int rectified = 0;
for(int rect=1; rect<=size(rectCheck);rect++)
{	
	if (rectified == 0)
	{
		//rectifying at location rf
		poly rf = rectCheck[rect];
		"checking for rectification at", rf;
		ideal ckt_imp = J1;
		
		int ind_r = get_index(ckt_imp, rf);
		int ind_Z = get_index(ckt_imp, Z);
		
		ideal IL = ckt_imp;
		IL[ind_r] = rf+1;
		ideal IH = ckt_imp;
		IH[ind_r] = rf;
		
		poly rL = reduce(spec,IL+J0);
		poly rH = reduce(spec,IH+J0);
		
		//"rL",rL;
		//"rH",rH;

		ideal rlh = groebner((rL*rH)+J0);
		//"ideal rlh is",rlh;
		int t3 = rtimer-t2;
		"time for rectification check until the correction net",t3;

		if (size(rlh)==size(J0))
		{	
			"Circuit Rectifiable at location",rf;
			int lenI = size(ckt_imp);
			ideal Jf = ckt_imp[1..(ind_r-1)];
			ideal Js = ckt_imp[(ind_r+1)..lenI];
			poly quo;
			poly rem;
			poly prem;
		
			prem = reduce(spec,Jf);
		
			rem, quo = multivariate_burg(prem,lead(rf),J0); 
		
			//"remainder",rem;
			//"quotient",quo;
		
			ideal dec = variables(quo);
			ideal JCp = quo,Js;
			if (size(dec)>=1)
			{
				"quotient is not a constant";
				ideal JG = slimgb(JCp);
				matrix V = lift(JG,rem);
				matrix Vt = transpose(V);
				//Vt;
				matrix U = lift(JCp,JG);
				//U;
				poly sol;
				int i;
				for(i=1;i<=size(JG);i++)
				{
					sol = sol + (Vt[1,i]*U[1,i]);
				}
			}
			else
			{	
				"quotient is a constant";
				if (quo != 1)
				{
					matrix quoi = inverse(quo);
				}
				else
				{
					matrix quoi = 1;
				}
				poly irem   = quoi[1,1]*rem;
				poly sol    = reduce(irem,Js+J0);	
			}
			"solution for P is",sol;
			int t4 = rtimer-t3;
			"time for identifying solution using UC",t4;
			poly correc = rf+sol;
			poly corem = reduce(spec, Jf+Js+correc+J0);
		
			"applying correction to circuit at",rf,"with solution",sol,":remainder after reduction is", corem;
			rectified = 1;
		}
		else
		{
			"Circuit not rectifiable at location",rf;
		}
	}
}
"end of computations",rtimer-t0;quit;