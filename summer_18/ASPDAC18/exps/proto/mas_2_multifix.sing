//LIB "multivariate_burg.lib";
LIB "my_proc.lib";
LIB "primdec.lib";
LIB "control.lib";
LIB "linalg.lib";
LIB "numerAlg.lib";

ring R = (2, x), (Z, A, B, z_0_, z_1_, r_0, e_0, e_1, e_2, e_3, s_5, s_4, s_3, s_2, s_1, s_0, a_0_, a_1_, b_1_, b_0_), lp; 
//elimination order
//ring r = (2, x), (Z, A, B, z_0_, z_1_, r_0, e_0, e_1, e_2, e_3, s_0, s_1, s_2, s_4, s_5, a_0_, a_1_, b_1_, s_3, b_0_), lp; 

minpoly = x^2 + x + 1;

proc xorgate(poly g, poly h)
{
	return(g+h);
}

proc andgate(poly g, poly h)
{
	return(g*h);
}

//circuit -  2 bit mastrovito multiplier poly's
//correct implementation
poly f1 = Z + z_0_ + z_1_*x;
poly f2 = A + a_0_ + a_1_*x;
poly f3 = B + b_0_ + b_1_*x;
poly f4 = z_0_ + xorgate(s_0,e_0);
poly f5 = z_1_ + xorgate(e_0,r_0);
poly f6 = r_0 + xorgate(e_1,s_5);
//poly f7 = e_0 + s_1*e_2;//correct
poly f7 = e_0 + s_1+e_2;//bug
poly f8 = e_1 + s_2*e_2;
poly f9 = e_2 + xorgate(e_3,s_4);
poly f10 = e_3 + b_0_*s_3;
//poly f11 = s_0 + a_0_*b_0_;//correct
poly f11 = s_0 + a_0_+b_0_;//bug
poly f12 = s_1 + a_1_*b_1_;
poly f13 = s_2 + a_1_*b_0_;
poly f14 = s_3 + a_0_ + b_0_ + a_0_*b_0_;
poly f15 = s_4 + b_0_ + 1;
poly f16 = s_5 + a_0_*b_1_;



//vanishing polynomials
poly f17 = a_0_^2 - a_0_;
poly f18 = a_1_^2 - a_1_;
poly f19 = b_1_^2 - b_1_;
poly f20 = b_0_^2 - b_0_;

//word level spec
poly spec = Z + A*B;

int dps = 2;

ideal J1 = f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16;
ideal J0 = f17,f18,f19,f20;

//check if the circuit indeed implements specification
poly rema = reduce(spec,J1+J0);
if (rema == 0)
{
	"circuit implements specification, exiting";
	quit;
}
else
{
	//"remainder",rema;
	"circuit doesn't implement specification, attempting rectification";
}
rema;dps;
list coneTips =  remainder_partition(rema,dps);

list rectCheck = prune_logical_cone(coneTips,J1);

int rectified = 0;
for(int rect=1; rect<=size(rectCheck);rect++)
{	
	if (rectified == 0)
	{
		//rectifying at location rf
		poly rf = rectCheck[rect];
		"checking for rectification at", rf;
		ideal ckt_imp = J1;
		
		int ind_r = get_index(ckt_imp, rf);
		int ind_Z = get_index(ckt_imp, Z);
		
		ideal IL = ckt_imp;
		IL[ind_r] = rf+1;
		ideal IH = ckt_imp;
		IH[ind_r] = rf;
		
		poly rL = reduce(spec,IL+J0);
		poly rH = reduce(spec,IH+J0);
		
		//"rL",rL;
		//"rH",rH;

		ideal rlh = groebner((rL*rH)+J0);
		//"ideal rlh is",rlh;
		int equal=1;
		if (size(rlh)==size(J0))
		{	
			list rr = sort(rlh);
			list rj = sort(J0);
			for (int j=1;j<=size(rr);j++)
			{	
				if(rr[1][j]!=rj[1][j])
				{
					equal = 0;
					break;
				}
			}			
		}
		else
		{
			equal = 0;
		}
		
		if(equal)	
		{	
			"Circuit Rectifiable at location",rf;
			int lenI = size(ckt_imp);
			ideal Jf = ckt_imp[1..(ind_r-1)];
			ideal Js = ckt_imp[(ind_r+1)..lenI];
			poly quo;
			poly rem;
			poly prem;
		
			prem = reduce(spec,Jf);
		
			rem, quo = multivariate_burg(prem,lead(rf),J0); 
		
			//"remainder",rem;
			//"quotient",quo;
		
			ideal dec = variables(quo);
			ideal JCp = quo,Js;
			if (size(dec)>=1)
			{
				"quotient is not a constant";
				ideal JG = slimgb(JCp);
				matrix V = lift(JG,rem);
				matrix Vt = transpose(V);
				//Vt;
				matrix U = lift(JCp,JG);
				//U;
				poly sol;
				int i;
				for(i=1;i<=size(JG);i++)
				{
					sol = sol + (Vt[1,i]*U[1,i]);
				}
			}
			else
			{	
				"quotient is a constant";
				if (quo != 1)
				{
					matrix quoi = inverse(quo);
				}
				else
				{
					matrix quoi = 1;
				}
				poly irem   = quoi[1,1]*rem;
				poly sol    = reduce(irem,Js+J0);	
			}
			"solution for P is",sol;
			poly correc = rf+sol;
			poly corem = reduce(spec, Jf+Js+correc+J0);
		
			"applying correction to circuit at",rf,"with solution",sol,":remainder after reduction is", corem;
			rectified = 1;
		}
		else
		{
			"Circuit not rectifiable at location",rf;
		}
	}
}
"end of computations",quit;