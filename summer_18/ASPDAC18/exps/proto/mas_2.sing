LIB "linalg.lib";
LIB "dmodapp.lib";
LIB "my_proc.lib";

ring R = (2, x), (Z, A, B, z_0, z_1, r_0, s_0, s_3, s_1, s_2, a_0, a_1, b_0, b_1), lp; 

rtimer=0;
system("--ticks-per-sec",1000);
int t0 = rtimer;

minpoly = x^2 + x + 1;

proc xorgate(poly g, poly h)
{
	return(g+h);
}

//circuit -  2 bit mastrovito multiplier poly's
//correct implementation
poly f1 = s_0 + a_0*b_0;
poly f2 = s_3 + a_1*b_1;
poly f3 = s_2 + a_1*b_0;
poly f4 = s_1 + a_0*b_1;
poly f5 = r_0 + xorgate(s_1,s_2);
poly f6 = z_0 + xorgate(s_0,s_3);
poly f7 = z_1 + xorgate(r_0,s_3);
poly f8 = A + a_0 + a_1*x;
poly f9 = B + b_0 + b_1*x;
poly f10= Z + z_0 + z_1*x;

//vanishing polynomials
poly f11 = a_0^2 - a_0;
poly f12 = a_1^2 - a_1;
poly f13 = b_0^2 - b_0;
poly f14 = b_1^2 - b_1;

poly f22 = Z^4 - Z;
poly f23 = A^4 - A;
poly f24 = B^4 - B;

//word level spec
poly spec = Z + A*B;

//list of polynomials for GB calculation
ideal J1  = f1, f2, f3, f4, f5, f6, f7, f8, f9, f10;
ideal J0 = f11, f12, f13, f14, f22, f23, f24;

int dps = 2;

poly rf = z_1;
ideal ckt_imp = J1;
int ind_r = get_index(ckt_imp, rf);
int lenI = size(ckt_imp);
ideal Js = ckt_imp[1..(ind_r-1)];
ideal Jf = ckt_imp[(ind_r+1)..lenI];
poly quo;
poly rem;
poly prem;
prem = reduce(spec,Jf);
rem, quo = multivariate_burg(prem,lead(rf),J0); 
//"remainder",rem;
//"quotient",quo;
ideal dec = variables(quo);
ideal JCp = quo,Js;
if (size(dec)>=1)
{
	"quotient is not a constant";
	ideal JG = slimgb(JCp);
	matrix V = lift(JG,rem);
	matrix Vt = transpose(V);
	//Vt;
	matrix U = lift(JCp,JG);
	//U;
	poly sol;
	int i;
	for(i=1;i<=size(JG);i++)
	{
		sol = sol + (Vt[1,i]*U[1,i]);
	}
}
else
{	
	"quotient is a constant";
	if (quo != 1)
	{
		matrix quoi = inverse(quo);
	}
	else
	{
		matrix quoi = 1;
	}
	poly irem   = quoi[1,1]*rem;
	poly sol    = reduce(irem,Js+J0);	
}
"solution for P is",sol;
poly correc = rf+sol;
ideal J = Jf,Js,correc,J0;

option(redSB);
ideal J1 = std(J);

int t1 = rtimer-t0;
"timer after sol", t1;

//modified ring order
ring R1 = (2, x), (Z, A, B, z_0, z_1, s_0, s_1, s_2, a_0, a_1, b_0, b_1, r_0, s_3), lp;

ideal subvar = fglm(R,J1);
subvar;

int t2 = rtimer-t1;
"timer at the end", t2;