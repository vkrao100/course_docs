/////////////////////////////////////////////////////////////
// Golden reference model for pipelined multiplier
//
// Authors         : Ken Stevens <kstevens@ece.utah.edu>
// Mod Date        : Jan 2010
// Revision        : 0.2
// Status          : 
// Bug Reports     : Ken Stevens <kstevens@ece.utah.edu>
//
// This program validates the design for a x^2 + 97y function block that
// has been designed in a four-deep pipeline.  It generates two random
// 8 bit values, and prints out their product.  This is used as a golden
// reference model for an n-bit multiplier on a chip.
// 
// Bugs:
//
// Improvements:
//
// Comments:
//
// Commands:
//   Compile with: "g++ -Wall -O -o goldenmodel goldenmodel.cpp"
//
///////////////////////////////////////////////////////////////


// include this to get decimal results:
//#define DECIMAL


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <assert.h>
#include <math.h>

// define parameters for the number of vectors and bit sizes
#define INPUTBITS   8	// size of input bits
#define NUMVECTORS 32	// default vector generation count
#define PIPESTAGES  4
// create a value to remove floating point errors in our random number generator
#define eps (1e-7)

int main(int argc, char **argv)
{
    unsigned char inA, inB;			// randomly generated inputs
    unsigned int res[PIPESTAGES+1];		// result pipeline
    int idx, vnum, vnumsz;			// vector indexes
    double range = pow(2, INPUTBITS) - 2 * eps;	// Range of random input

    // Initialize vector size count vnumsz based on passed argument or default.
    // Can improve this to include format, input bit size, pipe stages, etc.
    if (argc > 1) {
	if (*argv[1] < '1' || *argv[1] > '9') {
	    fprintf(stderr, "Usage:\n\n  Call %s with one optional integer argument\n  The integer indicates the number of vectors to be generated\n  Otherwise %d vectors will be generated by default\n\n",
		    *argv, NUMVECTORS);
	    return 1;
	} else {
	    vnumsz = atoi(argv[1]);
	    printf("\ngenerating %d vectors\n", vnumsz);
	}
    } else vnumsz = NUMVECTORS;

    // Initialize random number generator with a random seed.
    srand48(time(NULL));

    // reset pipeline
    for (idx = 0; idx <= PIPESTAGES; idx++)
	res[idx] = 0;

    for(vnum = 0; vnum < vnumsz; vnum++) {
	/* generate uniformly random integers in correct range */
	inA = (unsigned char) rint(range * drand48() - (0.5 - eps));
	inB = (unsigned char) rint(range * drand48() - (0.5 - eps));

	// Shift pipeline and add in new value
	for (idx = PIPESTAGES; idx; idx--) {
	    res[idx] = res[idx - 1];
	}
	res[0] = inA * inA + 97 * inB;

#ifdef DECIMAL
	printf("a = %3d, b = %3d, result = %5d\n", inA, inB, res[PIPESTAGES]);
#else
	printf("a = ");
	// print high to low order bits, testing if value is 1 or 0
	// by logical AND with 1 shifted by bit position.
	for(idx = INPUTBITS - 1; idx >= 0; idx--)
	    printf("%c", inA & (1<<idx) ? '1' : '0');
	printf(", b = ");
	for(idx = INPUTBITS - 1; idx >= 0; idx--)
	    printf("%c", inB & (1<<idx) ? '1' : '0');
	printf(", result = ");
	for(idx = 2 * INPUTBITS - 1; idx >= 0; idx--) {
	    printf("%c", res[PIPESTAGES] & (1<<idx) ? '1' : '0');
	}
	printf("\n");
#endif
    }
    return 0;
}
