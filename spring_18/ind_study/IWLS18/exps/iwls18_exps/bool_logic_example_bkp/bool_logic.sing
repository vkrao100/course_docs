LIB "multivariate_burg.lib";
LIB "control.lib";
//ring r = 2,(z,z1,z2,j0,i0,h0,g0,g1,g2,e0,e1,e2,e3,a,b,c,d),lp;
ring r = 2,(z,z1,z2,j0,g0,g2,e0,e1,e2,e3,a,b,c,d,i0,h0,g1),lp;

proc orgate(poly g,poly h)
{
	return(g+h-g*h);
}

proc xorgate(poly g,poly h)
{
	return(g+h-2*g*h);
}

proc invgate(poly g)
{
	return(1+g);
}

proc andgate(poly g,poly h)
{
	return(g*h);
}

poly spec = z + ac + ab + bc;

//circuit implementation
poly f1 = z + andgate(z1,z2);
poly f2 = z1 + andgate(e0,j0);
poly f3 = z2 + orgate(j0,d);
poly f4 = j0 + orgate(g0,i0);
poly f5 = i0 + andgate(g1,h0);//unknown gate
poly f6 = h0 + xorgate(e2,g2);
poly f7 = g0 + andgate(e0,c);
poly f8 = g1 + andgate(e1,a);
poly f9 = g2 + andgate(e3,c);
poly f10 = e0 + orgate(a,b);
poly f11 = e1 + b;
poly f12 = e2 + invgate(c);
poly f13 = e3 + orgate(c,d);

//vanishing polynomials
poly e_0 = e0^2 -e0;
poly e_1 = e1^2 -e1;
poly e_2 = e2^2 -e2;
poly e_3 = e3^2 -e3;
poly g_0 = g0^2 -g0;
poly g_1 = g1^2 -g1;
poly g_2 = g2^2 -g2;
poly h_0 = h0^2 -h0;
poly i_0 = i0^2 -i0;
poly j_0 = j0^2 -j0;
poly z_1 = z1^2 -z1;
poly z_2 = z2^2 -z2;
poly z_z = z^2 -z;

poly a_0 = a^2 - a;
poly b_0 = b^2 - b;
poly c_0 = c^2 - c;
poly d_0 = d^2 - d;

ideal J0i = a_0, b_0, c_0, d_0, e_0, e_1, e_2, e_3, g_0, g_1, g_2, h_0, i_0, j_0, z_1, z_2, z_z;
list J0 = a_0, b_0, c_0, d_0, e_0, e_1, e_2, e_3, g_0, g_1, g_2, h_0, i_0, j_0, z_1, z_2, z_z;

list JCl = f1,f2,f3,f4,f5;
poly rem = multivariate_burg(spec,(JCl+J0),J0i);

poly h5 = g0*e0 + e0;
poly ns = g0*e0 + ac + bc + ab; // f-h1*f1-h2*f2-h3*f3-h4*f4-h5*lt(f5)

ideal JCp = h5,f6,f7,f8,f9,f10,f11,f12,f13;
ideal Jq  = f6,f7,f8,f9,f10,f11,f12,f13;

matrix T3 = lift(JCp+J0i,ns);
T3;

poly P = T3[1,1];
poly P = ab;

ideal Gq  = groebner(quotient(Jq+J0i,h5));
Gq;