LIB "primdec.lib";
LIB "multivariate_burg.lib";
LIB "linalg.lib";
//ring r = integer, ( z3, z2, z1, s, z0, m, n, o, a_0, a_1, b_0, b_1), lp; 
ring r = integer, ( z3, z2, s, k, j, z1, i, z0, m, g, h, n, o, a_0, a_1, b_0, b_1), lp; 

proc xorgate(poly g, poly h)
{
	return(g+h-2*g*h);
}

proc orgate(poly g, poly h)
{
	return(g+h-g*h);
}

proc invgate(poly g)
{
	return(1-g);
}

proc andgate(poly g, poly h)
{
	return(g*h);
}
//correct implementation
poly f1 = z3 - s*o;
poly f2 = z2 - xorgate(s,o);
poly f3 = s  - k*n; //unknown component
poly f4 = k - m*j;
poly f5 = j - xorgate(g,i);
poly f6 = z1 - xorgate(m,n);
poly f7 = i - h*b_0;
poly f8 = z0 - a_0*b_0;
poly f9 = m  - a_1*b_0;
poly f10 = g - invgate(b_0);
poly f11 = h - orgate(a_1,b_0);
poly f12 = n  - a_0*b_1;
poly f13  = o  - a_1*b_1;

//buggy implementation
//introducing bug - OR gate instead of AND gate
poly fb3  = s - orgate(k,n);

//vanishing polynomials
poly f9   = a_0^2 - a_0;
poly f10  = a_1^2 - a_1;
poly f11  = b_0^2 - b_0;
poly f12  = b_1^2 - b_1;
poly f13  = z0^2 - z0;
poly f14  = z2^2 - z2;
poly f15  = z3^2 - z3;
poly f16  = s^2 - s;
poly f17  = o^2 - o;
poly f18  = m^2 - m;
poly f19  = n^2 - n;
poly f20  = z1^2 - z1;
poly f21 = g^2 - g;
poly f22 = h^2 - h;
poly f23 = i^2 - i;
poly f24 = j^2 - j;
poly f25 = k^2 - k;


ideal J1  = f1, f2;
ideal J2  = f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13;
ideal J0  = f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23, f24, f25;

/*poly h7 = 8;
ideal ns = 4*z2 + 2*z1 + z0 - 4*a_1*b_1 - 2*a_1*b_0 - 2*a_0*b_1 - a_0*b_0;
ideal Jp = h7, f1, f2, f3, f4, f5, f6, f7, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20;

ideal rBI  = f1, f2, f3, f4, f5, frb6, fr1, fr2, fr3, fr4, fr5, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, fr21, fr22, fr23, fr24, fr25;
ideal rCI  = f1, f2, f3, f4, f5, fr6, fr1, fr2, fr3, fr4, fr5, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, fr21, fr22, fr23, fr24, fr25;

matrix T = lift(Jp,ns);
T;*/

poly spec = 8*z3 + 4*z2 + 2*z1 + z0 - 4*a_1*b_1 - 2*a_1*b_0 - 2*a_0*b_1 - a_0*b_0 ;

poly uc = f1;

poly quo;
poly rem;

//poly prem = reduce(spec,J1+J0);

//"partial remainder",prem;

rem, quo = multivariate_burg(spec,lead(uc),J0); 

"remainder",rem;
"quotient",quo;

ideal dec = variables(quo);
ideal JCp = quo,J2;

JCp;

if (size(dec)>=1)
{
	"quotient is not a constant";
	matrix T3 = lift(JCp+J0,rem);
	poly sol  = T3[1,1];
}
else
{	
	"quotient is a constant";
	//matrix quoi = inverse(quo);
	//quoi;
	//poly irem   = quoi[1,1]*rem;
	//poly sol    = reduce(irem,J2);
	matrix T3 = lift(JCp+J0,rem);
	poly sol  = T3[1,1];
}

"solution for P is ",sol;