\section{Theory and Procedure}
\label{sec:theory}
In this section we describe the theory, and procedures used to arrive 
at a function and its implementation for the unknown component. We
also show how to explore the solution space for implementable functions. 

%\subsection{Reference specification is polynomial f}
Consider a specification polynomial $f$ and a gate-level circuit $C$
that implements $f$. Model the circuit by way of polynomials $F =
\{f_1,\dots,f_s\}\in \mathbb{F}_q[x_1,\dots, x_n]$, where
variables $x_1,\dots,x_n$ denote the nets in the circuit. The set $F$
generates an ideal $J=\langle F \rangle$, and let $J_0=\langle
x_l^q-x_l: 1\leq l\leq n\rangle$ be the set of all vanishing polynomials.

As described in \cite{lv:tcad2013}, the equivalence check between $f$
and $C$ can be formulated as an ideal membership test that checks if
$f \in J + J_0$. Thus, one can compute a \Grobner basis
$G=GB(J+J_0) = \{g_1,\dots,g_t\}$, and check if $f
\xrightarrow{G}_+0$? If the circuit $C$ indeed implements $f$, 
$f \xrightarrow{G}_+ 0$ and $f$ can be written as a linear combination
of $g_1\dots,g_t$, and also of $f_1\dots, f_s$, by virtue of
Eqns. (\ref{eqn:matrix}) and (\ref{eqn:imt}).

The \Grobner basis algorithm has very high exponential complexity
($q^{O(n)}$ in our case). In \cite{lv:tcad2013}, it was further shown
that this complexity can be overcome by deriving a specialized term
order by analyzing the topology of the given circuit. It relies on the
condition that {\it when the leading terms of all polynomials in a
generating set $F=\{f_1,\dots,f_s\}$ are relatively prime, then $F$
already constitutes a GB, i.e. $F = GB(F)$}. We restate the result:


\begin{Proposition} \label{prop:top-order}
(From \cite{lv:tcad2013}) Let $C$ be any arbitrary combinational
  circuit. Let $\{x_1, \dots, x_n\}$ denote the set of all variables
  (signals) in $C$. Starting from the primary outputs, perform
  a {\it reverse topological traversal} of the circuit and order the
  variables such that $x_i > x_j$ if $x_i$ appears earlier in the
  reverse topological order. Impose a {\it lex} term order $>$ to
  represent each gate as a polynomial $f_i$, s.t. $f_i = x_i +
  tail(f_i)$. Then the set of all polynomials  $\{f_1, \dots, f_s\}$
  forms a Gr\"obner basis G, as $lt(f_i)=x_i$ and $lt(f_j)=x_j$ for 
  $i\neq j$ are relatively prime. This term order $>$ is called the 
  {\bf Reverse Topological Term Order (RTTO)}.
\end{Proposition}

Imposition of RTTO $>$ on the polynomials of the circuit has the
effect of making every gate output variable $x_i$ a leading term of
$f_i$. Since every gate output is unique, $lm(f_i)=x_i, lm(f_j)=x_j
\forall i\neq j$ become relatively prime. As a result, the set $F$ 
already constitutes a GB ($G=F$). Moreover, it was further shown in
\cite{lv:tcad2013} that under RTTO, the set $F \cup F_0$ forms the
\Grobner basis of $J + J_0$. As a result, the verification test
can be carried out simply by the division of $f$ modulo the \Grobner
basis $F\cup F_0$ and checking if the remainder is 0; i.e. $f
\xrightarrow{F,F_0}_+r$, and checking if $r = 0$? When $C$ does
implement $f$, $r=0$ and $f = u_1f_1+\dots+u_sf_s + \sum_{i=1}^n
H_i\cdot(x_i^q-x_i)$. 

An important effect of RTTO $>$ is that each gate $\mathcal{G}_i$ is
represented by a polynomial of the type $f_i = x_i +
\text{tail}(f_i)$.  RTTO ensures that
every variable $x_j$ that appears in $\text{tail}(f_i)$ satisfies
$x_i>x_j$. These properties will be exploited in our technique. 

\subsection{The unknown component}
Now consider that verification has been performed between $f$ and $C$,
and it is found that $C$ {\bf does not} implement $f$. Further, assume
that post-verification debugging identifies the gate $\mathcal{G}_i
\in C$ with output net $x_i$ where a correction can be synthesized and
implemented to meet the specification. We consider the gate
$\mathcal{G}_i$ as the unknown component and attempt to identify a
function for $\mathcal{G}_i$. More precisely, {\it we have to compute
  a polynomial $f_i = x_i + \text{tail}(f_i)$ that identifies a
  function implementable at gate $\mathcal{G}_i$} such that the
circuit $C$ conforms to the specification $f$. 

First, we address the problem of computing a polynomial
$f_i$ of the form $f_i:x_i+P(X)$ as an implementation of
$\mathcal{G}_i$, where $x_i$ is the output of the gate
$\mathcal{G}_i$, $X \subset \{x_1,\dots,x_n\}$ is a subset of the nets
in the circuit that lie in the fanin cone of the gate $\mathcal{G}_i$,
and $P(X) = \text{tail}(f_i)$ is a polynomial in $X$-variables,
with coefficients in $\Fq$. Subsequently, we address the problem of
identifying $f_i:x_i+P(X_{im})$ as an implementation of
$\mathcal{G}_i$ where  $X_{im} \subset \{x_1,\dots,x_n\}$ is a {\it
  given} set of variables corresponding to the internal nets of the
circuit. This case corresponds to resolving the unknown component with
more topological constraints imposed on $P(X_{im})$ by the user; say,
when the immediate inputs ($X_{im}$) of the unknown gate
$\mathcal{G}_i$ are known.  {\it Note that here we assume that the
  unknown component can indeed be composed of the given $X_{im}$
  variables}. 


As described above, for a correct implementation,
$$f \in \langle f_1,..,f_s\rangle + \langle x_l^q-x_l: 1\le l \le n\rangle.$$

We impose RTTO $>$ on the ring, which ensures that the set
$\{f_1,\dots,f_s\}\cup \{x_1^q-x_1,\dots,x_n^q-x_n\}$ itself
constitutes a \Grobner basis. Thus
$f\xrightarrow{f_1,\dots,f_s,x_l^q-x_l}_+0$. Using Lemma
\ref{lem:imt}, we can rewrite $f$ in terms of its generators as:   

\begin{equation}\label{eqn1}
f = h_1f_1 + h_2f_2 + \dots+h_if_i+\dots+h_sf_s + \sum_{l=1}^n H_l
(x_l^q-x_l),
\end{equation}
where $h_1,\dots,h_s,H_1,\dots,H_n$ are arbitrary polynomials from the ring
$R$. Substituting $f_i = x_i + P$ for the unknown component in
Eqn. (\ref{eqn1}), we have: 

\begin{eqnarray}
  \begin{split}
    & f  = h_1f_1 +\dots+h_{i-1}f_{i-1}+h_ix_i+h_iP+\dots+h_sf_s\\
    & \quad +\sum_{l=1}^n H_l (x_l^q-x_l)
  \end{split}\\  
  \begin{split}
    & f - h_1f_1 -\dots-h_{i-1}f_{i-1}-h_ix_i = h_iP+h_{i+1}f_{i+1}+\\
    & \quad \dots+h_sf_s +\sum_{l=1}^n H_l (x_l^q-x_l) \label{eqn2}
\end{split}
\end{eqnarray}

Notice that on the L.H.S. of Eqn. (\ref{eqn2}), the polynomials $f,
f_1,\dots,f_{i-1}$ and the variable $x_i$ are known
expressions. Therefore, $f$ can be divided by $f_1,\dots,f_{i-1}$ and
$x_i$ to obtain the quotients of the division $h_1,\dots,h_i$ and a
remainder $r$ where $r = f - h_1f_1 - \dots-h_ix_i$.
After $h_i$ is computed (as the quotient of this division by $x_i$), 
the R.H.S. of Eqn. (\ref{eqn2}) consists of $h_i, f_{i+1}, \dots, f_s$
and all the vanishing polynomials $x_l^q-x_l$ as known
expressions. This implies that: 

\begin{eqnarray}
f - h_1f_1 - \dots-h_ix_i & \in \langle h_i,f_{i+1},\dots,f_s,  x_l^q-x_l\rangle\\
r & \in \langle h_i,f_{i+1},\dots,f_s, x_l^q-x_l\rangle\label{eqn3}
\end{eqnarray}

This ideal membership implies that $r$ can be written as some
polynomial combination of the generators $h_i,f_{i+1},\dots,f_s,
x_l^q-x_l$. This combination can be identified by first computing the
\Grobner basis $G$ of the ideal $\langle
h_i,f_{i+1},\dots,f_s,x_l^q-x_l\rangle$, and then performing the ideal
membership test $r\xrightarrow{G}_+0$, while utilizing
Eqns. (\ref{eqn:imt}) and (\ref{eqn:imt_orig}). As a result, we can
write:

\begin{align}
r & = h_i'h_i+h_{i+1}'f_{i+1}+\dots+h_s'f_s+ \sum_{l=1}^n H_l (x_l^q-x_l).
\end{align}

Then $P = h_i'$ is a polynomial that forms the solution to the
unknown component problem. Algorithmically, as $P = h_i'$ is computed
as a quotient of division, $P$ may contain any variables
$x_1,\dots,x_n$ in its support. However, due to the imposition of RTTO
$>$, $P$ will contain only those variables $x_j$ in its support set
that are less than $x_i$ in the reverse topological order. In this
fashion, the polynomial $f_i: x_i + P(X)$ can be identified to
implement the function of the gate $\mathcal{G}_i \in C$ so that $C$
correctly implements $f$. 

Note that in Eqn. (\ref{eqn3}), while $\{f_{i+1},\dots,f_s\}$
constitutes a GB under RTTO, $\{h_i,f_{i+1},\dots,f_s\}$
may not, so a GB computation may be required. On the other hand, we
may also encounter situations when $h_i$ ends up being a constant.
When a constant is a member of an ideal $J$, then $GB(J) = \{1\}$. To
arrive at an implementable solution in this case, we divide $h_i^{'}$
by the constant $h_i$(multiply the inverse of $h_i$) and reduce the result by
rest of the input polynomials\{$f_{i+1},\dots,f_s$\}.  

\begin{align}
h_i^{'}*h_i^{-1}\xrightarrow[]{f_{i+1}}\xrightarrow[]{f_{i+2}}\dots\xrightarrow[]{f_s}P
\end{align}


%% Despite being a correct solution, the above approach doesn't guarantee
%% the solution to be in the immediate support variables of $f_i$ due to
%% RTTO$>$. To determine a solution in immediate support variable set
%% $x_j$ of $f_i$, we use an elimination term order (\autoref{def:elim})
%% for the variables $x_k$ followed by $x_j$. We can then compute a $GB$
%% using this elimination term order with the intermediate solution $P$
%% added as tail of $f_i$. This $GB$ will have one and only one
%% polynomial which is of the form $x_k + \mathcal{F}(x_j)$, where
%% $\mathcal{F}$ is the function implemented by the gate, and is the most
%% desired solution.  

\subsection{Exploring the solution-space for the unknown component}

%Since we found two solutions, it is given that $P$ is not unique. We
%can explore more such solutions which might satisfy the unknown
%component functionality. Given $P$ as one of the solutions, under
%RTTO$>$ we have: 

From Eqn. (\ref{eqn3}), we have that $r$ can be written as a
polynomial combination of $h_i,f_{i+1},\dots, f_s$. However, this
combination need not be unique:
\begin{align*}
r &= P\cdot h_i+h_{i+1}f_{i+1}+\dots+h_sf_s+ \sum_{l=1}^n H_l (x_l^q-x_l)\\
r&= P^{'}\cdot h_i+h_{i+1}^{'}f_{i+1}+\dots+h_s^{'}f_s+\sum_{l=1}^n H_l' (x_l^q-x_l),
\end{align*}

Rearranging the terms from the above two equations:
\begin{equation}
  \begin{split}
(P-P^{'})h_i = &
    (h_{i+1}-h_{i+1}^{'})f_{i+1}+\dots+(h_{s}-h_{s}^{'})f_s\\
    & \quad + \sum_{l=1}^n (H_l-H_l') (x_l^q-x_l).
  \end{split}
\end{equation}

In other words, 
$(P-P^{'})h_i \in \langle f_{i+1},\dots,f_s,x_l^q-x_l\rangle$. 
From the definition of Quotient of Ideals (\autoref{def:quo}), we
observe that:
\vspace{0.1in}
\begin{equation}
\label{quotcomp}
P-P^{'} \in \langle f_{i+1},\dots,f_s,x_l^q-x_l\rangle : \langle h_i\rangle.
\end{equation}

There can be many polynomials $P^{'}$ which might satisfy the above
ideal membership. We now show how to explore more
solutions to the unknown component, i.e. given $P$, how to find a $P'$
that satisfies the above membership.  

Let $J_{Q} = \langle f_{i+1},\dots,f_s,x_l^q-x_l\rangle : \langle
h_i\rangle$, so $P - P' \in J_Q$. This implies that $P$ is congruent
to $P'$ modulo $J_Q$. In such a case, $P' = P + g$ s.t. $g\in
J_Q$. This is because:

\begin{align*}
%  P' &\equiv& P \pmod{ J_Q}\\
  P' &\equiv (P + g) \pmod{J_Q}\\
\implies  P' &\equiv P \pmod{ J_Q} + g \pmod{J_Q}\\
%\implies  P' &\equiv P \pmod{ J_Q} + g \pmod{J_Q}\\
\implies  P' &\equiv P \pmod{ J_Q} + 0 ~~(\text{as} ~g \in J_Q)  \\
\implies  P-P' &\equiv 0 \pmod{ J_Q}\\
\implies  P-P' & \in { J_Q}
\end{align*}

So we can chose any polynomial $g$ from the quotient
ideal $J_Q$ and compute $P' = P + g$. Since $J_Q$ is computed using
the \Grobner basis algorithm, we can chose $g \in GB(J_Q)$ to get $P'
= P + g$.


\subsubsection{Resolving the unknown component over a given set of
  variables} Once $P(X)$ is identified, where $X$ may be an
arbitrary set of variables, it may be desirable to express the
polynomial $P$ in terms of a given set of variables $X_{im}$. Here,
$X_{im}$ may correspond to, say, the known immediate inputs to the
gate $\mathcal{G}_i \in C$. This can be easily performed using the
concept of elimination term orders and elimination ideals.

Once a $P(X)$ is computed, we also compute $G_Q = GB(J_Q)$ with a
different term order where the variables $x_i > X_{im}$ are the last
in the order. In other words we use a lex order with: $X_{im} < x_i <
$ {\it all other circuit variables}. Then reducing
$P(X) \xrightarrow{G_Q}_+ r(X_{im})$ gives remainder $r$ whose
monomials will be composed of only the $X_{im}$ variables. Therefore,
$P(X_{im}) = r(X_{im})$ and the unknown component can be resolved as
the polynomial $f_i: x_i + r(X_{im})$.

We can further explore different implementation functions for the
unknown component. Select a polynomial $g \in G_Q$ such that $g \in
G_Q \cap \Fq[X_{im}]$ (elimination ideal). Then $f_i: x_i + (r(X_{im})
+ g)$ works as another replacement for the unknown component. This is
due to the fact that $(r(X_{im}) + g)
\xrightarrow{G_Q}_+r(X_{im})$. This way,  various functions for the
unknown component can be explored that depend on a given set $X_{im}$
variables. 


\subsection{Demonstration of our approach}

\begin{figure*}[hbt]
	\begin{center}
	\includegraphics[scale = 0.65]{mas_c}
	\end{center}
	\vspace{-2ex}
	\caption{A 2-bit finite field multiplier}
	\label{mas_c}
	\vspace{-1ex}
\end{figure*}

\begin{Example}
Consider an implementation of a 2-bit finite field multiplier  as shown
in~\autoref{mas_c}. The system is modeled over the ring
$R=\F_4[a_0,b_0,a_1,b_1,s_0,s_1,s_2,s_3,s_4,s_5,e_0,e_1,e_2,e_3,r_0,z_0,$
  $z_1,Z,A,B]$. The multiplier specification is given as $f: Z +
A\cdot B$, and our setup is as follows:
\begin{enumerate}
    \item{Field construction: $\F_4 = \F_2[X]$ (mod $\mathcal{P}$); where $\mathcal{P} = X^2 + X + 1$ is the primitive polynomial used.}
    \item{$Z = z_0 +\al z_1; A = a_0 +\al a_1; B = b_0 +\al b_1;$ are the word level polynomials, and $\al$ is the root of primitive polynomial s.t. $\mathcal{P}(\al)=0$.}
\end{enumerate}
Based on the circuit topology, RTTO$>$ with variable order:
$\{Z\}>\{A>B\}>\{z_0>z_1\}>\{r_0\}>\{e_0>e_1\}>\{e_2\}>\{e_3\}>\{s_0>s_1>s_2>s_3>s_4>s_5\}>\{a_0>a_1>b_0>b_1\}$\\ 
Let $F$ be the set of all polynomials implementing the circuit which is given as:
% \begin{equation*}
% \begin{split}
% f_1:s_0 + a_0*b_0;  &  f_5:r_0 + s_1 + s_2; & f_8:A + a_0 + a_1*\al; \\
% f_2:s_3 + \mathcal{F}(a_1,b_1);  &  f_6:z_0 + s_0 + s_3; & f_9:B + b_0 + b_1*\al;\\
% f_3:s_2 + a_1*b_0;  &  f_7:z_1 + r_0 + s_3; & f_{10}:Z + z_0 + z_1*\al;\\
% f_4:s_1 + a_0*b_1;
% \end{split}
% \begin{equation}
{\small\begin{flalign*}
f_1:Z + z_0 +\al z_1;  &\quad f_9:e_2 + e_3 + s_4;   \\
f_2:A + a_0 +\al a_1;  &\quad f_{10}:e_3 + b_0 + s_3; \\
f_3:B + b_0 +\al b_1;  &\quad f_{11}:s_0 + a_0b_0; \\
f_4:z_0 + s_0 + e_0;	&\quad f_{12}:s_1 + a_1b_1; \\
f_5:z_1 + e_0 + r_0;	&\quad f_{13}:s_2 + a_1b_0; \\
f_6:r_0 + e_1 + s_5;	&\quad f_{14}:s_3 + a_0 + b_0 + a_0b_0; \\
f_7:e_0 + s_1e_2;       &\quad f_{15}:s_4 + b_0 + 1;\\
f_8:e_1 + s_2e_2;		&\quad f_{16}:s_5 + a_0b_1;\\
\end{flalign*}}

Let $J_0 = \langle x_l^4 - x_l\rangle$ denote the ideal of vanishing
polynomials in $R$. 
%% We shall add the ideal of vanishing polynomials $J_0$ for primary inputs.  
%% {\small\begin{flalign*}
%% f_{17}:a_0^2 + a_0; \\
%% f_{18}:a_1^2 + a_1; \\
%% f_{19}:b_0^2 + b_0; \\
%% f_{20}:b_1^2 + b_1; 
%% \end{flalign*}}%
\begin{small}
Then $F = \{f_1,\dots,f_{16}\}, J = \langle F\rangle = \langle
f_1,\dots,f_{16}\rangle$
%J_0 = \langle f_{17},\dots,f_{20}\rangle$
\end{small}
% Due to RTTO$>$, the set of polynomials ($J+J_0$) is in itself a \Grobner basis.\\

For a correct implementation, the specification $f$ is in $J + J_0$.
%vanishes on circuit implementation~(\autoref{lem:imt}):

% \begin{equation}
$f \in \langle f_1,f_2,f_3,\dots,f_{16}\rangle+J_0$

$f \xrightarrow[]{GB(f_1\dots f_{16}, x_l^4-x_l)}_0$

% \end{equation}
% h_4f_4 \in \langle f,f_1,f_2,f_3,f_5,f_6,f_7\rangle\\
% h_4f_4 = f+h_1f_1+h_2f_2+h_3f_3+h_5f_5+h_6f_6+h_7f_7
Now, let us assume the marked gate $f_{10}$ is the \textit{unknown
  component} in the design which is of the form $f_{10} = e_3 + P$,
where $P$ is the unknown function to be implemented by the gate. We
know that under RTTO $>$, the given set of circuit polynomials $F$
itself form a $GB$. Hence to compute $r$, we start reducing the 
specification polynomial $f$ using polynomials from $\langle J + J_0\rangle$.  

We will use the following notations for reduction: '[]' to represent quotient-$h_j$'s, '()' to represent divisor-$f_j$'s, and '\{\}' to represent the partial remainder of every reduction step-$fp_j$'s.

\begin{small}
% \begin{split}
$f\xrightarrow[]{f_{1}}[1](Z + z_0 +\al z_1)+\{ AB+z_0+\al z_1\}\rightarrow fp_1$

$fp_1\xrightarrow[]{f_2}[B](A+a_0+\al a_1)+\{Ba_0+\al Ba_1+z_0+\al z_1\}\rightarrow fp_2$

$fp_2\xrightarrow[]{f_3}[a_0+\al a_1](B+b_0+\al b_1)+\{z_0+\al z_1+\al a_0b_1+a_0b_0+ (\al+1)a_1b_1 + \al a_1b_0\}\rightarrow fp_3$

$fp_3\xrightarrow[]{f_4}[1](z_0+e_0+s_0)+\{\al z_1+e_0+s_0+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}\rightarrow fp_4$

$fp_4\xrightarrow[]{f_5}[\al](z_1+r_0+e_0)+\{\al z_1+e_0+s_0+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}\rightarrow fp_5$

$fp_5\xrightarrow[]{f_6}[\al](r_0+e_1+s_5)+\{(\al+1)e_0+\al e_1+s_0+\al s_5+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}\rightarrow fp_6$

$fp_6\xrightarrow[]{f_7}[\al+1](e_0+e_2*s_1)+\{\al e_1+(\al+1)e_2s_1+s_0+\al s_5+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}\rightarrow fp_7$

$fp_7\xrightarrow[]{f_8}[\al](e_1+e_2*s_2)+\{(\al+1)e_2s_1+\al e_2s_2 + s_0+\al s_5+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}\rightarrow fp_8$

$fp_8\xrightarrow[]{f_9}[(\al+1)s_1 + \al s_2](e_2+e_3+s_4)+\{(\al+1)e_3s_1+ \al e_3s_2 +s_0+(\al+1)s_1s_4+\al s_2s_4+\al s_5+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}\rightarrow fp_9$
\end{small}

\begin{small}

${\scriptstyle fp_9}\xrightarrow[]{{\scriptstyle lt(f_{10})}}[\underbrace{{\scriptstyle (\al+1)s_1+\al s_2}}_\text{$h_{10}$}]({\scriptstyle e_3})+$ 

$\{\underbrace{{\scriptstyle s_0+(\al+1)s_1s_4+\al s_2s_4+\al s_5+\al a_0b_1+a_0b_0+(\al+1)a_1b_1+\al a_1b_0\}}}_\text{$r$}$ 
\end{small}
% \end{split}

Reduction order for $f:$

$f\xrightarrow[]{f_{1}}\xrightarrow[]{f_2}\xrightarrow[]{f_3}\xrightarrow[]{f_4}\xrightarrow[]{f_5}\xrightarrow[]{f_6}\xrightarrow[]{f_7}\xrightarrow[]{f_8}\xrightarrow[]{f_9}\xrightarrow[]{lt(f_{10})}r$

% \begin{equation}
% \begin{split}
% h_4f_4+h_1f_1+h_2f_2+h_3f_3 = f+h_5f_5+h_6f_6+h_7f_7;\\
% h_4(d_0+P(e_1,c))+h_1f_1+h_2f_2+h_3f_3 = f+h_5f_5+h_6f_6+h_7f_7;\\
% h_4*d_0+h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = f+h_5f_5+h_6f_6+h_7f_7;\\
% h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = h_4*d_0+f+h_5f_5+h_6f_6+h_7f_7;\\
% h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = e_0*e_2+a*c+a+b*c+b+c;\\
% h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = e_0*e_2+a*c+a+b*c+b+c;
% \end{split}
% \end{equation}
Given: $r,h_{10},f_{11},f_{12},f_{13},f_{14},f_{15},f_{16},J_0$, the
problem can be formulated as an ideal membership test
using \eqref{eqn3} such that: 
\begin{center}
$r \in \langle h_{10},f_{11},f_{12},f_{13},f_{14},f_{15},f_{16}\rangle + \langle J_0\rangle$
\end{center}

The above ideal membership can be solved by expressing $r$ as a
linear combination of the ideal members (~\autoref{lem:imt}). 
\begin{small}
$r = Ph_{10} + h_{11}f_{11} + h_{12}f_{12}+h_{13}f_{13}+h_{14}f_{14}+h_{15}f_{15}+h_{16}f_{16}$ 
\end{small}

In our example, polynomial $r$ can be expressed as
%a linear combination ~(\autoref{lem:imt}) in given member ideal as
%follows:   

% \end{split}
% \end{equation}
\begin{small}
$r = [b_0]h_{10}+[1]f_{11}+[\al+1]f_{12}+[\al s_4 +\al b_0]f_{13}+[0]f_{14}+[(\al+1)s_1+\al a_1b_0]f_{15}+[\al]f_{16}+[0]f_{17}+[0]f_{18}+[0]f_{19}+[0]f_{20}$;
\end{small}

Thus computed $P=b_0$ is a solution to the \textit{unknown component}
$f_{10}$; i.e. $f_{10}: e_3 + b_0$.

Given a solution $P$, we can explore the solution space for 
the gate $f_i$ in terms of variables $x_j$ such that $x_i>x_j$ in the
variable order.
%This can be achieved by computing a quotient of
%ideals~(\autoref{def:quo}) and using different elimination
%ideals~(\autoref{def:elimideal}) with desired variables $x_j$ moved to
%the end of the variable order. 
In our example, $r$ can be written as:
% any linear combination of the ideals:

\begin{align*}
  \begin{split}
    r &= Ph_{10} + h_{11}f_{11} + h_{12}f_{12}+h_{13}f_{13}+h_{14}f_{14}\\
      &\quad +h_{15}f_{15}+h_{16}f_{16}+HJ_0
  \end{split}\\
  \begin{split}
  r & = P'h_{10} + h_{11}'f_{11} +  h_{12}'f_{12}+h_{13}'f_{13}+h_{14}'f_{14}\\
  &\quad +h_{15}'f_{15}+h_{16}'f_{16} + H'J_0
\end{split}
\end{align*}

Re-writing the above two equations:\\
\begin{align}
  \begin{split}
    (P-P')h_{10} &= (h_{11}-h_{11}')f_{11} + (h_{12}-h_{12}')f_{12}\\
    & \quad +\dots+(h_{16}-h_{16}')f_{16}+(H-H')J_0
  \end{split}\\
(P-P')h_{10} & \in  \langle f_{11},f_{12},\dots,f_{16},J_0\rangle\\
(P-P')       &\in     \langle f_{11},f_{12},\dots,f_{16},J_0\rangle:h_{10}\\
(P-P')       & \in  Q
\end{align}

The above expression for $J_Q$ represents the quotient of ideals
operation~(\autoref{def:quo}). We can pick any polynomial within
desired variable subset $x_j$ from the result of $J_Q$ and add it to the
computed solution $P$ to arrive at a new solution. 

Under the current $RTTO >$ variable order, the quotient of ideals
operation results in the following polynomials:\\ 
\begin{small}
$g[1]=b_1b_0+b_1+b_0+1\\
g[2]=(\al+1)b_1+(\al+1)*b_1*b_0+(\al+1)*b_0+(\al+1)\\
g[3]=a_1+1\\
g[4]=s_5+a_0b_1\\
g[5]=s_4+b_0+1\\
g[6]=s_3+a_0b_0+a_0+b_0\\
g[7]=s_2+b_0\\
g[8]=s_1+b_1\\
g[9]=s_0+a_0b_0$
\end{small}

Any $P+g[k]$, where $1<k<9$, will work as a solution for the
\textit{unknown component} $f_{10}$. 

Now assume that we know the immediate input variables of the
polynomial $f_{10}$ as $X_{im} = (b_0,s_3)$, we can compute a solution
in terms of these variables by using the elimination
ideal $J_Q \cap \Fq[b_0,s_3]$. The quotient
operation with the elimination ideal results in:\\ 
\begin{small}
$g[1]=s_3b_0 + b_0$
\end{small}

Since, there is only one $g$ from the operation, $P+g[1]=s_3b_0$ also
works as a solution for the \textit{unknown component}: $f_{10}: e_3 +
s_3b_0$. 

\end{Example}

%% \begin{Example}
%% Consider the 2-bit Mastrovito multiplier given in fig.~\ref{mas_c} with variables from ring $\R=\F_2[a_0,b_0$ $,a_1,b_1,s_0,s_1,s_2,s_3,r_0,z_0,z_1,Z,A,B]$. Let us assume $f_2$ to be the unknown gate in the design which is of the form $f_2 = s_3 + P$.\\%\mathcal{F}(a_1,b_1)$.\\


%% % For the given circuit, we define \textit{cuts} across the gates based on heuristics such as dependency and levelization\cite{maciej:2016:1}. A $cut$ is defined as a set of signals that separates primary inputs from primary outputs. The prominence of these cuts is to maintain a variable order across cuts . For example at each cut $cut_m$ from the figure(\ref{tianka_ckt_c}), the following variable set has to be maintained across reductions.
%% % \begin{equation}
%% % \begin{split}
%% % cut_0 = \{a,b,c\} &\quad cut_3= \{z_1,z_2\}\\
%% % cut_1 = \{e_0,e_1,c,e_2\}  &\quad cut_4 = \{z\} \\
%% % cut_2 = \{e_0,d_0,e_2\}
%% % \end{split}
%% % \end{equation}
%% The 2x2 Mastrovito multiplier with specification $f: Z + A\cdot B$, is constructed as follows:
%% % \begin{lalign*}
%% % \begin{split}
%% \begin{enumerate}
%%     \item{Field construction: $\F_4 = \F_2[X]$ (mod $\mathcal{P}$); where $\mathcal{P} = X^2 + X + 1$ is the primitive polynomial used.}
%%     \item{$Z = z_0 + z_1*\al; A = a_0 + a_1*\al; B = b_0 + b_1*\al;$ are the word level polynomials, and $\al$ is the root of primitive polynomial s.t. $\mathcal{P}(\al)=0$.}
%% \end{enumerate}
%% Based on the circuit topology, RTTO$>$ with variable order:
%% $\{Z\}>\{A>B\}>\{z_0>z_1\}>\{r_0>s_0>s_3\}>\{s_1>s_2$ $\}>\{a_0>a_1>b_0>b_1\}$\\ 
%% Let $F$ be the set of all polynomials implementing the circuit which are given as:
%% % \begin{equation*}
%% % \begin{split}
%% % f_1:s_0 + a_0*b_0;  &  f_5:r_0 + s_1 + s_2; & f_8:A + a_0 + a_1*\al; \\
%% % f_2:s_3 + \mathcal{F}(a_1,b_1);  &  f_6:z_0 + s_0 + s_3; & f_9:B + b_0 + b_1*\al;\\
%% % f_3:s_2 + a_1*b_0;  &  f_7:z_1 + r_0 + s_3; & f_{10}:Z + z_0 + z_1*\al;\\
%% % f_4:s_1 + a_0*b_1;
%% % \end{split}
%% % \begin{equation}
%% {\small\begin{flalign*}
%% f_1:s_0 + a_0*b_0;  &\quad  f_5:r_0 + s_1 + s_2; & f_8:A + a_0 + a_1*\al;\\
%% % f_2:s_3 + \mathcal{F}(a_1,b_1);  &\quad  f_6:z_0 + s_0 + s_3; & f_9:B + b_0 + b_1*\al;\\
%% f_2:s_3 + P;  &\quad  f_6:z_0 + s_0 + s_3; & f_9:B + b_0 + b_1*\al;\\
%% f_3:s_2 + a_1*b_0;  &\quad  f_7:z_1 + r_0 + s_3; & f_{10}:Z + z_0 + z_1*\al;\\
%% f_4:s_1 + a_0*b_1;
%% \end{flalign*}}%
%% We shall add the ideal of vanishing polynomials $J_0$ for primary inputs, outputs, and intermediate variables.  
%% {\small\begin{flalign*}
%% f_{11}:a_0^2 + a_0; &\quad f_{15}:s_0^2 + s_0;\quad f_{19}:r_0^2 + r_0;\quad f_{23}:A^4 + A;\\
%% f_{12}:a_1^2 + a_1; &\quad f_{16}:s_1^2 + s_1;\quad f_{20}:z_0^2 + z_0;\quad f_{24}:B^4 + B;\\
%% f_{13}:b_0^2 + b_0; &\quad f_{17}:s_2^2 + s_2;\quad f_{21}:z_1^2 + z_1;\\
%% f_{14}:b_1^2 + b_1; &\quad f_{18}:s_3^2 + s_3;\quad f_{22}:Z^4 + Z;
%% \end{flalign*}}%
%% \begin{small}
%% $F = \{f_1,\dots,f_{10}\}; J = \langle F\rangle = \langle f_1,\dots,f_{10}\rangle; J_0 = \langle f_{11},\dots,f_{24}\rangle$
%% \end{small}
%% % Due to RTTO$>$, the set of polynomials ($J+J_0$) is in itself a \Grobner basis.\\

%% For a correct implementation, specification $f$ vanishes on circuit implementation:
%% % \begin{equation}
%% $f \in \langle f_1,f_2,f_3,\dots,f_{10}\rangle+\langle f_{11},f_{12}$ $,\dots,f_{24}\rangle$,
%% % \end{equation}
%%  where tail of $f_2$ is unknown.
%% % h_4f_4 \in \langle f,f_1,f_2,f_3,f_5,f_6,f_7\rangle\\
%% % h_4f_4 = f+h_1f_1+h_2f_2+h_3f_3+h_5f_5+h_6f_6+h_7f_7

%% We know that under RTTO$>$, the given set of circuit polynomials in itself form a $GB$. Hence to compute $g$, we start reducing the specification polynomial $f$ using polynomials from the set $\langle J + J_0\rangle$. We will use the following notations for reduction: '[]' to represent quotient-$h_i$'s, '()' to represent divisor-$f_i$'s, and '\{\}' to represent the partial remainder of every reduction step-$fp_i$'s.

%% \begin{small}
%% % \begin{split}
%% $f\xrightarrow[]{f_{10}}[1](Z + z_0 + z_1*\al)+\{ A*B+z_0+\al*z_1\}\rightarrow fp_1$

%% $fp_1\xrightarrow[]{f_8}[B](A+a_0+\al*a_1)+\{B*a_0+\al*B*a_1+z_0+\al*z_1\}\rightarrow fp_2$

%% $fp_2\xrightarrow[]{f_9}[a_0+\al*a_1](B+b_0+\al*b_1)+\{z_0+\al*z_1+a_0*b_0+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1\}\rightarrow fp_3$

%% $fp_3\xrightarrow[]{f_6}[z_0+s_0+s_3](1)+\{\al*z_1+s_0+s_3+a_0*b_0+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1\}\rightarrow fp_4$

%% $fp_4\xrightarrow[]{f_7}[z_1+r_0+s_3](\al)+\{\al*r_0+s_0+(\al+1)*s_3+a_0*b_0+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1\}\rightarrow fp_5$

%% $fp_5\xrightarrow[]{f_5}[r_0+s_1+s_2](\al)+\{s_0+(\al+1)*s_3+\al*s_1+\al*s_2+a_0*b_0+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1\}\rightarrow fp_6$

%% $fp_6\xrightarrow[]{f_1}[s_0+a_0*b_0](1)+\{(\al+1)*s_3+\al*s_1+\al*s_2+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1\}\rightarrow fp_7$

%% % $fp_6\quad\xrightarrow[]{lt(f_2)}[s_3](\underbrace{x+1}_\text{$h_2$})+\{\underbrace{(x)*s_1+(x)*s_2+(x)*a_0*b_1+(x)*a_1*b_0+(x+1)*a_1*b_1}_\text{$g$}\}$
%% ${\scriptstyle fp_7}\xrightarrow[]{{\scriptstyle lt(f_2)}}[{\scriptstyle s_3}](\underbrace{{\scriptstyle \al+1}}_\text{$h_2$})+\{\underbrace{{\scriptstyle\al s_1+\al s_2+\al a_0b_1+\al a_1b_0+(\al+1)a_1b_1}}_\text{$g$}\}$


%% % \end{split}
%% \end{small}
%% Reduction order for $f:$
%% $f\xrightarrow[]{f_{10}}\xrightarrow[]{f_8}\xrightarrow[]{f_9}\xrightarrow[]{f_6}\xrightarrow[]{f_7}\xrightarrow[]{f_5}\xrightarrow[]{f_1}\xrightarrow[]{lt(f_2)}g$

%% % \begin{equation}
%% % \begin{split}
%% % h_4f_4+h_1f_1+h_2f_2+h_3f_3 = f+h_5f_5+h_6f_6+h_7f_7;\\
%% % h_4(d_0+P(e_1,c))+h_1f_1+h_2f_2+h_3f_3 = f+h_5f_5+h_6f_6+h_7f_7;\\
%% % h_4*d_0+h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = f+h_5f_5+h_6f_6+h_7f_7;\\
%% % h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = h_4*d_0+f+h_5f_5+h_6f_6+h_7f_7;\\
%% % h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = e_0*e_2+a*c+a+b*c+b+c;\\
%% % h_4*P(e_1,c)+h_1f_1+h_2f_2+h_3f_3 = e_0*e_2+a*c+a+b*c+b+c;
%% % \end{split}
%% % \end{equation}
%% Since, we know $g,h_2,f_3,f_4,J_0$, we can formulate it as ideal membership testing problem using~\eqref{member}:
%% \begin{center}
%% $g \in \langle h_2,f_3,f_4\rangle + \langle J_0\rangle$
%% \end{center}

%% This ideal membership test can be done using $lift$ procedure in SINGULAR~\cite{DGPS_410}. The procedure takes polynomial $f$, and ideal $J$ in row matrix form($[J+J_0]$) as inputs, and returns a column matrix $[U]$ as output such that:
%% \begin{small}
%% $f = [U]\cdot [J+J_0]$
%% \end{small}

%% % \begin{equation}
%% % \begin{split}
%% \begin{small}
%% $g = \begin{bmatrix} h_2^{'} & h_3^{'} & \dots & H \end{bmatrix} \cdot 
%%     \begin{bmatrix} h_2 \\ f_3 \\ \vdots \\ x_n^2 + x_n \end{bmatrix}$
%% \end{small}

%% The matrix output can be written in a linear combination as follows: 
%% % \end{split}
%% % \end{equation}
%% \begin{small}
%% $\al*s_1+\al*s_2+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1 = [\al*s_1+\al*s_2+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1](\al+1) + [0](s_2 + a_1*b_0) + [0](s_1 + a_0*b_1) + \dots + [0](x_n^2 + x_n)$;
%% \end{small}

%% The $lift$ procedure uses $GB$ to compute the linear combination. Since the generator set has a constant polynomial($\al+1$), the procedure considers it as constant one during membership computation. Hence the output in this case will be a 1x1 matrix with $g$ itself projected as the solution. To normalize the ignored constant, we need to divide(multiply the inverse) the solution $g$ by the constant$(\al+1)$ and reduce it with polynomials \{$f_3,f_4$\} in order to arrive at a implementable solution.

%% \begin{small}
%% $(\al+1)^{-1} = \al$

%% $h_2^{''} = \al*h_2^{'} = \al*(\al*s_1+\al*s_2+\al*a_0*b_1+\al*a_1*b_0+(\al+1)*a_1*b_1)$

%% $h_2^{''} = (\al+1)*s_1+(\al+1)*s_2+(\al+1)*a_0*b_1+(\al+1)*a_1*b_0+ a_1*b_1$

%% $h_2^{''}\xrightarrow[]{f_{3}}\xrightarrow[]{f_4}\underbrace{a_1*b_1}_\text{P}$
%% \end{small}

%% This computed $P$ is a valid solution and can be used as tail of $f_2$. If the resulting $P$ were not a solution in immediate support variables of $s_3$($a_1,b_1$), we could have arrived at this desired solution by devising a new term order. The new term order will have variables $(s_3,a_1,b_1)$ moved to the end on the variable order. We could then compute a $GB$ using the modified term order with the intermediate solution $P$ added as tail of $f_2$. This $GB$ will have one and only one polynomial which is of the form $s_3 + \mathcal{F}(a_1,b_1)$, where $\mathcal{F}$ is the function implemented by the gate for these variables.\\
%% Modified term order $\{Z\}>\{A>B\}>\{z_0>z_1\}>\{r_0>s_0\}>\{s_1>s_2$ $\}>\{a_0>b_0>s_3>a_1>b_1\}$.\\
%% To illustrate the computation of multiple solutions, let's take the current solution $a_1*b_1$ as our $P$. With RTTO$>$ as our term order, from~\eqref{quotcomp}:

%% $a_1*b_1 - P^{'} \in \{f_3,f_4,x_l^q-x_l\}:h_2$;\\
%% The result from quotient of ideal operation is given as:
%% {\small\begin{flalign*}
%% f_3:s_2 + a_1*b_0;  f_{13}:b_0^2 + b_0; f_{23}:A^4 + A;\\
%% f_4:s_1 + a_0*b_1;  f_{14}:b_1^2 + b_1; f_{24}:B^4 + B; \\
%% f_{11}:a_0^2 + a_0; f_{16}:s_1^2 + s_1; \\
%% f_{12}:a_1^2 + a_1; f_{17}:s_2^2 + s_2;
%% \end{flalign*}}%
%% Any polynomial from the above list when added in tail of $f_2$ along with $P$ satisfies the solution set for the given unknown component.
%% \end{Example}

\subsection{Circuit implementation as reference}
Consider a circuit implementation $C$, modeled as polynomials $F = \{f_1,\dots,f_s\}\in \mathbb{F}_q[in_j,x_1,\dots, x_n]$, with $J_1=\langle F \rangle$, $in_j$ as the set of all primary inputs, and $x_n$ as the word level output. Let us assume $f_i:1\le i \le s$ to be the unknown component which is of the special form:
\begin{gather*} 
f_i = x_k + P
\end{gather*}

Let us consider a different circuit $C_1$ as the golden specification which implements the same function as $C$. The reference circuit is modeled as polynomials $Q = \{q_1,\dots q_r\}\in \mathbb{F}_q[in_j,y_1,\dots, y_m]$, with $J_2=\langle Q \rangle$, $in_j$ as the set of all primary inputs, and $y_m$ as the word level output.

To formulate the problem, we will derive a new circuit structure using the above two implementations ($C,C_1$). Primary input set $in_j$ will be used as the common set of inputs for both the circuits, and the word level outputs ($x_n,y_m$) will be mitered using an XOR gate. A new specification polynomial $f$ is derived using the above setup as:
\begin{gather}
f : t*(x_n-y_m)
\end{gather}

where, $t$ is the final output of miter gate.

Now, for a correct implementation, specification $f$ should vanish on the variety of ideal generated by the circuit polynomials i.e., $f$ will be in the ideal generated by the circuit:

$f \in J_1 + J_2 + J_0$: where $J_0$ is the set of all vanishing polynomials from circuits $C$, $C_1$ and miter output $t$.

{\small $f \in \langle f_1,\dots,f_s\rangle + \langle q_1,\dots,q_r\rangle + \langle x_l^q-x_l\rangle + \langle y_u^q-y_u\rangle + \langle t^q-t\rangle$; $1\le l \le n,1\le u \le m$}

The problem formulation is now exactly same as~\eqref{member} with $f_i$ from circuit $C$ as the unknown gate. Now, we will follow the same procedure as in the first notion to realize the function of the unknown component. Once a solution has been computed, we can verify the circuit using principles from weak $\it{Nullstellensatz}$ by checking if $GB(J_1+J_2+J_0)=\{1\}$.

% \begin{algorithm}
% \caption{Resolve the unknown component for a given circuit}
% \label{algo:unknownComponent}
% \begin{algorithmic}[1]

% \Procedure{$multi\_variate\_division$}{$F,f$}

% \Procedure{$forward\_lifting$}{}

% \EndProcedure
% \end{algorithmic}
% \end{algorithm}

% Thus, $P(u_1)=P(e_1,c)=c$, which can implemented as a simple AND gate with $c$ as both inputs. 

% \begin{figure}[ht]
% 	\begin{center}
% 	\includegraphics[scale = 0.40]{mas_c}
% 	\end{center}
% 	\vspace{-1ex}
% 	\caption{correct implementation mastrovito}
% 	\label{mas_c}
% 	\vspace{-1ex}
% \end{figure}

% \begin{figure}[ht]
% 	\begin{center}
% 	\includegraphics[scale = 0.40]{mas_b}
% 	\end{center}
% 	\vspace{-4ex}
% 	\caption{buggy implementation mastrovito}
% 	\label{mas_b}
% 	\vspace{-2ex}
% \end{figure}
